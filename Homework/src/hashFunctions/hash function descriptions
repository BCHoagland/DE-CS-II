hash function for part 1:

I messed around a lot with multiplying an integer representation of each char in the board string with its position in the string. I could not manipulate what I multiplied the char value by to the point where I got no collisions, though, until I found the formula in the textbook. I tried using a coefficient of 3 because we're working with three different characters, and sure enough I got no collisions.

--------------------------------------------------------------

hash function for part 2:

I wanted to work with the same exponent idea as from part 1, so I started changing number around to see if I got different results. I tried multiplying by powers of 3 in the reverse order as in part 1. I also used modulo to fit every element into the array. What I spent most of the time on was trying to optimize the algorithm I had by changing which integers the three possible characters were represented by. I ended up choosing to represent each character with a prime number to minimize collisions, and I ran through each permutation of numbers to find the setup with the smallest average chain length. Since the array capacities are different in parts 2 and 3, the character conversion uses different integers in those parts.